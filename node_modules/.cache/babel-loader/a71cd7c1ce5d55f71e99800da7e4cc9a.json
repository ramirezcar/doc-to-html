{"ast":null,"code":"var _ = require(\"underscore\");\n\nvar options = require(\"option\");\n\nvar results = require(\"./parsing-results\");\n\nvar errors = require(\"./errors\");\n\nvar lazyIterators = require(\"./lazy-iterators\");\n\nexports.token = function (tokenType, value) {\n  var matchValue = value !== undefined;\n  return function (input) {\n    var token = input.head();\n\n    if (token && token.name === tokenType && (!matchValue || token.value === value)) {\n      return results.success(token.value, input.tail(), token.source);\n    } else {\n      var expected = describeToken({\n        name: tokenType,\n        value: value\n      });\n      return describeTokenMismatch(input, expected);\n    }\n  };\n};\n\nexports.tokenOfType = function (tokenType) {\n  return exports.token(tokenType);\n};\n\nexports.firstOf = function (name, parsers) {\n  if (!_.isArray(parsers)) {\n    parsers = Array.prototype.slice.call(arguments, 1);\n  }\n\n  return function (input) {\n    return lazyIterators.fromArray(parsers).map(function (parser) {\n      return parser(input);\n    }).filter(function (result) {\n      return result.isSuccess() || result.isError();\n    }).first() || describeTokenMismatch(input, name);\n  };\n};\n\nexports.then = function (parser, func) {\n  return function (input) {\n    var result = parser(input);\n\n    if (!result.map) {\n      console.log(result);\n    }\n\n    return result.map(func);\n  };\n};\n\nexports.sequence = function () {\n  var parsers = Array.prototype.slice.call(arguments, 0);\n\n  var rule = function rule(input) {\n    var result = _.foldl(parsers, function (memo, parser) {\n      var result = memo.result;\n      var hasCut = memo.hasCut;\n\n      if (!result.isSuccess()) {\n        return {\n          result: result,\n          hasCut: hasCut\n        };\n      }\n\n      var subResult = parser(result.remaining());\n\n      if (subResult.isCut()) {\n        return {\n          result: result,\n          hasCut: true\n        };\n      } else if (subResult.isSuccess()) {\n        var values;\n\n        if (parser.isCaptured) {\n          values = result.value().withValue(parser, subResult.value());\n        } else {\n          values = result.value();\n        }\n\n        var remaining = subResult.remaining();\n        var source = input.to(remaining);\n        return {\n          result: results.success(values, remaining, source),\n          hasCut: hasCut\n        };\n      } else if (hasCut) {\n        return {\n          result: results.error(subResult.errors(), subResult.remaining()),\n          hasCut: hasCut\n        };\n      } else {\n        return {\n          result: subResult,\n          hasCut: hasCut\n        };\n      }\n    }, {\n      result: results.success(new SequenceValues(), input),\n      hasCut: false\n    }).result;\n\n    var source = input.to(result.remaining());\n    return result.map(function (values) {\n      return values.withValue(exports.sequence.source, source);\n    });\n  };\n\n  rule.head = function () {\n    var firstCapture = _.find(parsers, isCapturedRule);\n\n    return exports.then(rule, exports.sequence.extract(firstCapture));\n  };\n\n  rule.map = function (func) {\n    return exports.then(rule, function (result) {\n      return func.apply(this, result.toArray());\n    });\n  };\n\n  function isCapturedRule(subRule) {\n    return subRule.isCaptured;\n  }\n\n  return rule;\n};\n\nvar SequenceValues = function SequenceValues(values, valuesArray) {\n  this._values = values || {};\n  this._valuesArray = valuesArray || [];\n};\n\nSequenceValues.prototype.withValue = function (rule, value) {\n  if (rule.captureName && rule.captureName in this._values) {\n    throw new Error(\"Cannot add second value for capture \\\"\" + rule.captureName + \"\\\"\");\n  } else {\n    var newValues = _.clone(this._values);\n\n    newValues[rule.captureName] = value;\n\n    var newValuesArray = this._valuesArray.concat([value]);\n\n    return new SequenceValues(newValues, newValuesArray);\n  }\n};\n\nSequenceValues.prototype.get = function (rule) {\n  if (rule.captureName in this._values) {\n    return this._values[rule.captureName];\n  } else {\n    throw new Error(\"No value for capture \\\"\" + rule.captureName + \"\\\"\");\n  }\n};\n\nSequenceValues.prototype.toArray = function () {\n  return this._valuesArray;\n};\n\nexports.sequence.capture = function (rule, name) {\n  var captureRule = function captureRule() {\n    return rule.apply(this, arguments);\n  };\n\n  captureRule.captureName = name;\n  captureRule.isCaptured = true;\n  return captureRule;\n};\n\nexports.sequence.extract = function (rule) {\n  return function (result) {\n    return result.get(rule);\n  };\n};\n\nexports.sequence.applyValues = function (func) {\n  // TODO: check captureName doesn't conflict with source or other captures\n  var rules = Array.prototype.slice.call(arguments, 1);\n  return function (result) {\n    var values = rules.map(function (rule) {\n      return result.get(rule);\n    });\n    return func.apply(this, values);\n  };\n};\n\nexports.sequence.source = {\n  captureName: \"☃source☃\"\n};\n\nexports.sequence.cut = function () {\n  return function (input) {\n    return results.cut(input);\n  };\n};\n\nexports.optional = function (rule) {\n  return function (input) {\n    var result = rule(input);\n\n    if (result.isSuccess()) {\n      return result.map(options.some);\n    } else if (result.isFailure()) {\n      return results.success(options.none, input);\n    } else {\n      return result;\n    }\n  };\n};\n\nexports.zeroOrMoreWithSeparator = function (rule, separator) {\n  return repeatedWithSeparator(rule, separator, false);\n};\n\nexports.oneOrMoreWithSeparator = function (rule, separator) {\n  return repeatedWithSeparator(rule, separator, true);\n};\n\nvar zeroOrMore = exports.zeroOrMore = function (rule) {\n  return function (input) {\n    var values = [];\n    var result;\n\n    while ((result = rule(input)) && result.isSuccess()) {\n      input = result.remaining();\n      values.push(result.value());\n    }\n\n    if (result.isError()) {\n      return result;\n    } else {\n      return results.success(values, input);\n    }\n  };\n};\n\nexports.oneOrMore = function (rule) {\n  return exports.oneOrMoreWithSeparator(rule, noOpRule);\n};\n\nfunction noOpRule(input) {\n  return results.success(null, input);\n}\n\nvar repeatedWithSeparator = function repeatedWithSeparator(rule, separator, isOneOrMore) {\n  return function (input) {\n    var result = rule(input);\n\n    if (result.isSuccess()) {\n      var mainRule = exports.sequence.capture(rule, \"main\");\n      var remainingRule = zeroOrMore(exports.then(exports.sequence(separator, mainRule), exports.sequence.extract(mainRule)));\n      var remainingResult = remainingRule(result.remaining());\n      return results.success([result.value()].concat(remainingResult.value()), remainingResult.remaining());\n    } else if (isOneOrMore || result.isError()) {\n      return result;\n    } else {\n      return results.success([], input);\n    }\n  };\n};\n\nexports.leftAssociative = function (leftRule, rightRule, func) {\n  var rights;\n\n  if (func) {\n    rights = [{\n      func: func,\n      rule: rightRule\n    }];\n  } else {\n    rights = rightRule;\n  }\n\n  rights = rights.map(function (right) {\n    return exports.then(right.rule, function (rightValue) {\n      return function (leftValue, source) {\n        return right.func(leftValue, rightValue, source);\n      };\n    });\n  });\n  var repeatedRule = exports.firstOf.apply(null, [\"rules\"].concat(rights));\n  return function (input) {\n    var start = input;\n    var leftResult = leftRule(input);\n\n    if (!leftResult.isSuccess()) {\n      return leftResult;\n    }\n\n    var repeatedResult = repeatedRule(leftResult.remaining());\n\n    while (repeatedResult.isSuccess()) {\n      var remaining = repeatedResult.remaining();\n      var source = start.to(repeatedResult.remaining());\n      var right = repeatedResult.value();\n      leftResult = results.success(right(leftResult.value(), source), remaining, source);\n      repeatedResult = repeatedRule(leftResult.remaining());\n    }\n\n    if (repeatedResult.isError()) {\n      return repeatedResult;\n    }\n\n    return leftResult;\n  };\n};\n\nexports.leftAssociative.firstOf = function () {\n  return Array.prototype.slice.call(arguments, 0);\n};\n\nexports.nonConsuming = function (rule) {\n  return function (input) {\n    return rule(input).changeRemaining(input);\n  };\n};\n\nvar describeToken = function describeToken(token) {\n  if (token.value) {\n    return token.name + \" \\\"\" + token.value + \"\\\"\";\n  } else {\n    return token.name;\n  }\n};\n\nfunction describeTokenMismatch(input, expected) {\n  var error;\n  var token = input.head();\n\n  if (token) {\n    error = errors.error({\n      expected: expected,\n      actual: describeToken(token),\n      location: token.source\n    });\n  } else {\n    error = errors.error({\n      expected: expected,\n      actual: \"end of tokens\"\n    });\n  }\n\n  return results.failure([error], input);\n}","map":{"version":3,"sources":["C:/Users/Carlos/Desktop/Coding/doc-to-html/node_modules/lop/lib/rules.js"],"names":["_","require","options","results","errors","lazyIterators","exports","token","tokenType","value","matchValue","undefined","input","head","name","success","tail","source","expected","describeToken","describeTokenMismatch","tokenOfType","firstOf","parsers","isArray","Array","prototype","slice","call","arguments","fromArray","map","parser","filter","result","isSuccess","isError","first","then","func","console","log","sequence","rule","foldl","memo","hasCut","subResult","remaining","isCut","values","isCaptured","withValue","to","error","SequenceValues","firstCapture","find","isCapturedRule","extract","apply","toArray","subRule","valuesArray","_values","_valuesArray","captureName","Error","newValues","clone","newValuesArray","concat","get","capture","captureRule","applyValues","rules","cut","optional","some","isFailure","none","zeroOrMoreWithSeparator","separator","repeatedWithSeparator","oneOrMoreWithSeparator","zeroOrMore","push","oneOrMore","noOpRule","isOneOrMore","mainRule","remainingRule","remainingResult","leftAssociative","leftRule","rightRule","rights","right","rightValue","leftValue","repeatedRule","start","leftResult","repeatedResult","nonConsuming","changeRemaining","actual","location","failure"],"mappings":"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","sourcesContent":["var _ = require(\"underscore\");\nvar options = require(\"option\");\nvar results = require(\"./parsing-results\");\nvar errors = require(\"./errors\");\nvar lazyIterators = require(\"./lazy-iterators\");\n\nexports.token = function(tokenType, value) {\n    var matchValue = value !== undefined;\n    return function(input) {\n        var token = input.head();\n        if (token && token.name === tokenType && (!matchValue || token.value === value)) {\n            return results.success(token.value, input.tail(), token.source);\n        } else {\n            var expected = describeToken({name: tokenType, value: value});\n            return describeTokenMismatch(input, expected);\n        }\n    };\n};\n\nexports.tokenOfType = function(tokenType) {\n    return exports.token(tokenType);\n};\n\nexports.firstOf = function(name, parsers) {\n    if (!_.isArray(parsers)) {\n        parsers = Array.prototype.slice.call(arguments, 1);\n    }\n    return function(input) {\n        return lazyIterators\n            .fromArray(parsers)\n            .map(function(parser) {\n                return parser(input);\n            })\n            .filter(function(result) {\n                return result.isSuccess() || result.isError();\n            })\n            .first() || describeTokenMismatch(input, name);\n    };\n};\n\nexports.then = function(parser, func) {\n    return function(input) {\n        var result = parser(input);\n        if (!result.map) {\n            console.log(result);\n        }\n        return result.map(func);\n    };\n};\n\nexports.sequence = function() {\n    var parsers = Array.prototype.slice.call(arguments, 0);\n    var rule = function(input) {\n        var result = _.foldl(parsers, function(memo, parser) {\n            var result = memo.result;\n            var hasCut = memo.hasCut;\n            if (!result.isSuccess()) {\n                return {result: result, hasCut: hasCut};\n            }\n            var subResult = parser(result.remaining());\n            if (subResult.isCut()) {\n                return {result: result, hasCut: true};\n            } else if (subResult.isSuccess()) {\n                var values;\n                if (parser.isCaptured) {\n                    values = result.value().withValue(parser, subResult.value());\n                } else {\n                    values = result.value();\n                }\n                var remaining = subResult.remaining();\n                var source = input.to(remaining);\n                return {\n                    result: results.success(values, remaining, source),\n                    hasCut: hasCut\n                };\n            } else if (hasCut) {\n                return {result: results.error(subResult.errors(), subResult.remaining()), hasCut: hasCut};\n            } else {\n                return {result: subResult, hasCut: hasCut};\n            }\n        }, {result: results.success(new SequenceValues(), input), hasCut: false}).result;\n        var source = input.to(result.remaining());\n        return result.map(function(values) {\n            return values.withValue(exports.sequence.source, source);\n        });\n    };\n    rule.head = function() {\n        var firstCapture = _.find(parsers, isCapturedRule);\n        return exports.then(\n            rule,\n            exports.sequence.extract(firstCapture)\n        );\n    };\n    rule.map = function(func) {\n        return exports.then(\n            rule,\n            function(result) {\n                return func.apply(this, result.toArray());\n            }\n        );\n    };\n    \n    function isCapturedRule(subRule) {\n        return subRule.isCaptured;\n    }\n    \n    return rule;\n};\n\nvar SequenceValues = function(values, valuesArray) {\n    this._values = values || {};\n    this._valuesArray = valuesArray || [];\n};\n\nSequenceValues.prototype.withValue = function(rule, value) {\n    if (rule.captureName && rule.captureName in this._values) {\n        throw new Error(\"Cannot add second value for capture \\\"\" + rule.captureName + \"\\\"\");\n    } else {\n        var newValues = _.clone(this._values);\n        newValues[rule.captureName] = value;\n        var newValuesArray = this._valuesArray.concat([value]);\n        return new SequenceValues(newValues, newValuesArray);\n    }\n};\n\nSequenceValues.prototype.get = function(rule) {\n    if (rule.captureName in this._values) {\n        return this._values[rule.captureName];\n    } else {\n        throw new Error(\"No value for capture \\\"\" + rule.captureName + \"\\\"\");\n    }\n};\n\nSequenceValues.prototype.toArray = function() {\n    return this._valuesArray;\n};\n\nexports.sequence.capture = function(rule, name) {\n    var captureRule = function() {\n        return rule.apply(this, arguments);\n    };\n    captureRule.captureName = name;\n    captureRule.isCaptured = true;\n    return captureRule;\n};\n\nexports.sequence.extract = function(rule) {\n    return function(result) {\n        return result.get(rule);\n    };\n};\n\nexports.sequence.applyValues = function(func) {\n    // TODO: check captureName doesn't conflict with source or other captures\n    var rules = Array.prototype.slice.call(arguments, 1);\n    return function(result) {\n        var values = rules.map(function(rule) {\n            return result.get(rule);\n        });\n        return func.apply(this, values);\n    };\n};\n\nexports.sequence.source = {\n    captureName: \"☃source☃\"\n};\n\nexports.sequence.cut = function() {\n    return function(input) {\n        return results.cut(input);\n    };\n};\n\nexports.optional = function(rule) {\n    return function(input) {\n        var result = rule(input);\n        if (result.isSuccess()) {\n            return result.map(options.some);\n        } else if (result.isFailure()) {\n            return results.success(options.none, input);\n        } else {\n            return result;\n        }\n    };\n};\n\nexports.zeroOrMoreWithSeparator = function(rule, separator) {\n    return repeatedWithSeparator(rule, separator, false);\n};\n\nexports.oneOrMoreWithSeparator = function(rule, separator) {\n    return repeatedWithSeparator(rule, separator, true);\n};\n\nvar zeroOrMore = exports.zeroOrMore = function(rule) {\n    return function(input) {\n        var values = [];\n        var result;\n        while ((result = rule(input)) && result.isSuccess()) {\n            input = result.remaining();\n            values.push(result.value());\n        }\n        if (result.isError()) {\n            return result;\n        } else {\n            return results.success(values, input);\n        }\n    };\n};\n\nexports.oneOrMore = function(rule) {\n    return exports.oneOrMoreWithSeparator(rule, noOpRule);\n};\n\nfunction noOpRule(input) {\n    return results.success(null, input);\n}\n\nvar repeatedWithSeparator = function(rule, separator, isOneOrMore) {\n    return function(input) {\n        var result = rule(input);\n        if (result.isSuccess()) {\n            var mainRule = exports.sequence.capture(rule, \"main\");\n            var remainingRule = zeroOrMore(exports.then(\n                exports.sequence(separator, mainRule),\n                exports.sequence.extract(mainRule)\n            ));\n            var remainingResult = remainingRule(result.remaining());\n            return results.success([result.value()].concat(remainingResult.value()), remainingResult.remaining());\n        } else if (isOneOrMore || result.isError()) {\n            return result;\n        } else {\n            return results.success([], input);\n        }\n    };\n};\n\nexports.leftAssociative = function(leftRule, rightRule, func) {\n    var rights;\n    if (func) {\n        rights = [{func: func, rule: rightRule}];\n    } else {\n        rights = rightRule;\n    }\n    rights = rights.map(function(right) {\n        return exports.then(right.rule, function(rightValue) {\n            return function(leftValue, source) {\n                return right.func(leftValue, rightValue, source);\n            };\n        });\n    });\n    var repeatedRule = exports.firstOf.apply(null, [\"rules\"].concat(rights));\n    \n    return function(input) {\n        var start = input;\n        var leftResult = leftRule(input);\n        if (!leftResult.isSuccess()) {\n            return leftResult;\n        }\n        var repeatedResult = repeatedRule(leftResult.remaining());\n        while (repeatedResult.isSuccess()) {\n            var remaining = repeatedResult.remaining();\n            var source = start.to(repeatedResult.remaining());\n            var right = repeatedResult.value();\n            leftResult = results.success(\n                right(leftResult.value(), source),\n                remaining,\n                source\n            );\n            repeatedResult = repeatedRule(leftResult.remaining());\n        }\n        if (repeatedResult.isError()) {\n            return repeatedResult;\n        }\n        return leftResult;\n    };\n};\n\nexports.leftAssociative.firstOf = function() {\n    return Array.prototype.slice.call(arguments, 0);\n};\n\nexports.nonConsuming = function(rule) {\n    return function(input) {\n        return rule(input).changeRemaining(input);\n    };\n};\n\nvar describeToken = function(token) {\n    if (token.value) {\n        return token.name + \" \\\"\" + token.value + \"\\\"\";\n    } else {\n        return token.name;\n    }\n};\n\nfunction describeTokenMismatch(input, expected) {\n    var error;\n    var token = input.head();\n    if (token) {\n        error = errors.error({\n            expected: expected,\n            actual: describeToken(token),\n            location: token.source\n        });\n    } else {\n        error = errors.error({\n            expected: expected,\n            actual: \"end of tokens\"\n        });\n    }\n    return results.failure([error], input);\n}\n"]},"metadata":{},"sourceType":"script"}