{"ast":null,"code":"var rules = require(\"./rules\");\n\nvar results = require(\"./parsing-results\");\n\nexports.parser = function (name, prefixRules, infixRuleBuilders) {\n  var self = {\n    rule: rule,\n    leftAssociative: leftAssociative,\n    rightAssociative: rightAssociative\n  };\n  var infixRules = new InfixRules(infixRuleBuilders.map(createInfixRule));\n  var prefixRule = rules.firstOf(name, prefixRules);\n\n  function createInfixRule(infixRuleBuilder) {\n    return {\n      name: infixRuleBuilder.name,\n      rule: lazyRule(infixRuleBuilder.ruleBuilder.bind(null, self))\n    };\n  }\n\n  function rule() {\n    return createRule(infixRules);\n  }\n\n  function leftAssociative(name) {\n    return createRule(infixRules.untilExclusive(name));\n  }\n\n  function rightAssociative(name) {\n    return createRule(infixRules.untilInclusive(name));\n  }\n\n  function createRule(infixRules) {\n    return apply.bind(null, infixRules);\n  }\n\n  function apply(infixRules, tokens) {\n    var leftResult = prefixRule(tokens);\n\n    if (leftResult.isSuccess()) {\n      return infixRules.apply(leftResult);\n    } else {\n      return leftResult;\n    }\n  }\n\n  return self;\n};\n\nfunction InfixRules(infixRules) {\n  function untilExclusive(name) {\n    return new InfixRules(infixRules.slice(0, ruleNames().indexOf(name)));\n  }\n\n  function untilInclusive(name) {\n    return new InfixRules(infixRules.slice(0, ruleNames().indexOf(name) + 1));\n  }\n\n  function ruleNames() {\n    return infixRules.map(function (rule) {\n      return rule.name;\n    });\n  }\n\n  function apply(leftResult) {\n    var currentResult;\n    var source;\n\n    while (true) {\n      currentResult = applyToTokens(leftResult.remaining());\n\n      if (currentResult.isSuccess()) {\n        source = leftResult.source().to(currentResult.source());\n        leftResult = results.success(currentResult.value()(leftResult.value(), source), currentResult.remaining(), source);\n      } else if (currentResult.isFailure()) {\n        return leftResult;\n      } else {\n        return currentResult;\n      }\n    }\n  }\n\n  function applyToTokens(tokens) {\n    return rules.firstOf(\"infix\", infixRules.map(function (infix) {\n      return infix.rule;\n    }))(tokens);\n  }\n\n  return {\n    apply: apply,\n    untilExclusive: untilExclusive,\n    untilInclusive: untilInclusive\n  };\n}\n\nexports.infix = function (name, ruleBuilder) {\n  function map(func) {\n    return exports.infix(name, function (parser) {\n      var rule = ruleBuilder(parser);\n      return function (tokens) {\n        var result = rule(tokens);\n        return result.map(function (right) {\n          return function (left, source) {\n            return func(left, right, source);\n          };\n        });\n      };\n    });\n  }\n\n  return {\n    name: name,\n    ruleBuilder: ruleBuilder,\n    map: map\n  };\n}; // TODO: move into a sensible place and remove duplication\n\n\nvar lazyRule = function lazyRule(ruleBuilder) {\n  var rule;\n  return function (input) {\n    if (!rule) {\n      rule = ruleBuilder();\n    }\n\n    return rule(input);\n  };\n};","map":{"version":3,"sources":["C:/Users/Carlos/Desktop/Coding/doc-to-html/node_modules/lop/lib/bottom-up.js"],"names":["rules","require","results","exports","parser","name","prefixRules","infixRuleBuilders","self","rule","leftAssociative","rightAssociative","infixRules","InfixRules","map","createInfixRule","prefixRule","firstOf","infixRuleBuilder","lazyRule","ruleBuilder","bind","createRule","untilExclusive","untilInclusive","apply","tokens","leftResult","isSuccess","slice","ruleNames","indexOf","currentResult","source","applyToTokens","remaining","to","success","value","isFailure","infix","func","result","right","left","input"],"mappings":"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","sourcesContent":["var rules = require(\"./rules\");\nvar results = require(\"./parsing-results\");\n\nexports.parser = function(name, prefixRules, infixRuleBuilders) {\n    var self = {\n        rule: rule,\n        leftAssociative: leftAssociative,\n        rightAssociative: rightAssociative\n    };\n    \n    var infixRules = new InfixRules(infixRuleBuilders.map(createInfixRule));\n    var prefixRule = rules.firstOf(name, prefixRules);\n    \n    function createInfixRule(infixRuleBuilder) {\n        return {\n            name: infixRuleBuilder.name,\n            rule: lazyRule(infixRuleBuilder.ruleBuilder.bind(null, self))\n        };\n    }\n    \n    function rule() {\n        return createRule(infixRules);\n    }\n    \n    function leftAssociative(name) {\n        return createRule(infixRules.untilExclusive(name));\n    }\n    \n    function rightAssociative(name) {\n        return createRule(infixRules.untilInclusive(name));\n    }\n    \n    function createRule(infixRules) {\n        return apply.bind(null, infixRules);\n    }\n    \n    function apply(infixRules, tokens) {\n        var leftResult = prefixRule(tokens);\n        if (leftResult.isSuccess()) {\n            return infixRules.apply(leftResult);\n        } else {\n            return leftResult;\n        }\n    }\n    \n    return self;\n};\n\nfunction InfixRules(infixRules) {\n    function untilExclusive(name) {\n        return new InfixRules(infixRules.slice(0, ruleNames().indexOf(name)));\n    }\n    \n    function untilInclusive(name) {\n        return new InfixRules(infixRules.slice(0, ruleNames().indexOf(name) + 1));\n    }\n    \n    function ruleNames() {\n        return infixRules.map(function(rule) {\n            return rule.name;\n        });\n    }\n    \n    function apply(leftResult) {\n        var currentResult;\n        var source;\n        while (true) {\n            currentResult = applyToTokens(leftResult.remaining());\n            if (currentResult.isSuccess()) {\n                source = leftResult.source().to(currentResult.source());\n                leftResult = results.success(\n                    currentResult.value()(leftResult.value(), source),\n                    currentResult.remaining(),\n                    source\n                )\n            } else if (currentResult.isFailure()) {\n                return leftResult;\n            } else {\n                return currentResult;\n            }\n        }\n    }\n    \n    function applyToTokens(tokens) {\n        return rules.firstOf(\"infix\", infixRules.map(function(infix) {\n            return infix.rule;\n        }))(tokens);\n    }\n    \n    return {\n        apply: apply,\n        untilExclusive: untilExclusive,\n        untilInclusive: untilInclusive\n    }\n}\n\nexports.infix = function(name, ruleBuilder) {\n    function map(func) {\n        return exports.infix(name, function(parser) {\n            var rule = ruleBuilder(parser);\n            return function(tokens) {\n                var result = rule(tokens);\n                return result.map(function(right) {\n                    return function(left, source) {\n                        return func(left, right, source);\n                    };\n                });\n            };\n        });\n    }\n    \n    return {\n        name: name,\n        ruleBuilder: ruleBuilder,\n        map: map\n    };\n}\n\n// TODO: move into a sensible place and remove duplication\nvar lazyRule = function(ruleBuilder) {\n    var rule;\n    return function(input) {\n        if (!rule) {\n            rule = ruleBuilder();\n        }\n        return rule(input);\n    };\n};\n"]},"metadata":{},"sourceType":"script"}