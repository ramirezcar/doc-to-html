{"ast":null,"code":"\"use strict\";\n\nmodule.exports = function (Promise, INTERNAL) {\n  var THIS = {};\n\n  var util = require(\"./util\");\n\n  var nodebackForPromise = require(\"./nodeback\");\n\n  var withAppended = util.withAppended;\n  var maybeWrapAsError = util.maybeWrapAsError;\n  var canEvaluate = util.canEvaluate;\n\n  var TypeError = require(\"./errors\").TypeError;\n\n  var defaultSuffix = \"Async\";\n  var defaultPromisified = {\n    __isPromisified__: true\n  };\n  var noCopyProps = [\"arity\", \"length\", \"name\", \"arguments\", \"caller\", \"callee\", \"prototype\", \"__isPromisified__\"];\n  var noCopyPropsPattern = new RegExp(\"^(?:\" + noCopyProps.join(\"|\") + \")$\");\n\n  var defaultFilter = function defaultFilter(name) {\n    return util.isIdentifier(name) && name.charAt(0) !== \"_\" && name !== \"constructor\";\n  };\n\n  function propsFilter(key) {\n    return !noCopyPropsPattern.test(key);\n  }\n\n  function isPromisified(fn) {\n    try {\n      return fn.__isPromisified__ === true;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  function hasPromisified(obj, key, suffix) {\n    var val = util.getDataPropertyOrDefault(obj, key + suffix, defaultPromisified);\n    return val ? isPromisified(val) : false;\n  }\n\n  function checkValid(ret, suffix, suffixRegexp) {\n    for (var i = 0; i < ret.length; i += 2) {\n      var key = ret[i];\n\n      if (suffixRegexp.test(key)) {\n        var keyWithoutAsyncSuffix = key.replace(suffixRegexp, \"\");\n\n        for (var j = 0; j < ret.length; j += 2) {\n          if (ret[j] === keyWithoutAsyncSuffix) {\n            throw new TypeError(\"Cannot promisify an API that has normal methods with '%s'-suffix\\n\\n    See http://goo.gl/MqrFmX\\n\".replace(\"%s\", suffix));\n          }\n        }\n      }\n    }\n  }\n\n  function promisifiableMethods(obj, suffix, suffixRegexp, filter) {\n    var keys = util.inheritedDataKeys(obj);\n    var ret = [];\n\n    for (var i = 0; i < keys.length; ++i) {\n      var key = keys[i];\n      var value = obj[key];\n      var passesDefaultFilter = filter === defaultFilter ? true : defaultFilter(key, value, obj);\n\n      if (typeof value === \"function\" && !isPromisified(value) && !hasPromisified(obj, key, suffix) && filter(key, value, obj, passesDefaultFilter)) {\n        ret.push(key, value);\n      }\n    }\n\n    checkValid(ret, suffix, suffixRegexp);\n    return ret;\n  }\n\n  var escapeIdentRegex = function escapeIdentRegex(str) {\n    return str.replace(/([$])/, \"\\\\$\");\n  };\n\n  var makeNodePromisifiedEval;\n\n  if (!false) {\n    var switchCaseArgumentOrder = function switchCaseArgumentOrder(likelyArgumentCount) {\n      var ret = [likelyArgumentCount];\n      var min = Math.max(0, likelyArgumentCount - 1 - 3);\n\n      for (var i = likelyArgumentCount - 1; i >= min; --i) {\n        ret.push(i);\n      }\n\n      for (var i = likelyArgumentCount + 1; i <= 3; ++i) {\n        ret.push(i);\n      }\n\n      return ret;\n    };\n\n    var argumentSequence = function argumentSequence(argumentCount) {\n      return util.filledRange(argumentCount, \"_arg\", \"\");\n    };\n\n    var parameterDeclaration = function parameterDeclaration(parameterCount) {\n      return util.filledRange(Math.max(parameterCount, 3), \"_arg\", \"\");\n    };\n\n    var parameterCount = function parameterCount(fn) {\n      if (typeof fn.length === \"number\") {\n        return Math.max(Math.min(fn.length, 1023 + 1), 0);\n      }\n\n      return 0;\n    };\n\n    makeNodePromisifiedEval = function makeNodePromisifiedEval(callback, receiver, originalName, fn, _, multiArgs) {\n      var newParameterCount = Math.max(0, parameterCount(fn) - 1);\n      var argumentOrder = switchCaseArgumentOrder(newParameterCount);\n      var shouldProxyThis = typeof callback === \"string\" || receiver === THIS;\n\n      function generateCallForArgumentCount(count) {\n        var args = argumentSequence(count).join(\", \");\n        var comma = count > 0 ? \", \" : \"\";\n        var ret;\n\n        if (shouldProxyThis) {\n          ret = \"ret = callback.call(this, {{args}}, nodeback); break;\\n\";\n        } else {\n          ret = receiver === undefined ? \"ret = callback({{args}}, nodeback); break;\\n\" : \"ret = callback.call(receiver, {{args}}, nodeback); break;\\n\";\n        }\n\n        return ret.replace(\"{{args}}\", args).replace(\", \", comma);\n      }\n\n      function generateArgumentSwitchCase() {\n        var ret = \"\";\n\n        for (var i = 0; i < argumentOrder.length; ++i) {\n          ret += \"case \" + argumentOrder[i] + \":\" + generateCallForArgumentCount(argumentOrder[i]);\n        }\n\n        ret += \"                                                             \\n\\\n        default:                                                             \\n\\\n            var args = new Array(len + 1);                                   \\n\\\n            var i = 0;                                                       \\n\\\n            for (var i = 0; i < len; ++i) {                                  \\n\\\n               args[i] = arguments[i];                                       \\n\\\n            }                                                                \\n\\\n            args[i] = nodeback;                                              \\n\\\n            [CodeForCall]                                                    \\n\\\n            break;                                                           \\n\\\n        \".replace(\"[CodeForCall]\", shouldProxyThis ? \"ret = callback.apply(this, args);\\n\" : \"ret = callback.apply(receiver, args);\\n\");\n        return ret;\n      }\n\n      var getFunctionCode = typeof callback === \"string\" ? \"this != null ? this['\" + callback + \"'] : fn\" : \"fn\";\n      var body = \"'use strict';                                                \\n\\\n        var ret = function (Parameters) {                                    \\n\\\n            'use strict';                                                    \\n\\\n            var len = arguments.length;                                      \\n\\\n            var promise = new Promise(INTERNAL);                             \\n\\\n            promise._captureStackTrace();                                    \\n\\\n            var nodeback = nodebackForPromise(promise, \" + multiArgs + \");   \\n\\\n            var ret;                                                         \\n\\\n            var callback = tryCatch([GetFunctionCode]);                      \\n\\\n            switch(len) {                                                    \\n\\\n                [CodeForSwitchCase]                                          \\n\\\n            }                                                                \\n\\\n            if (ret === errorObj) {                                          \\n\\\n                promise._rejectCallback(maybeWrapAsError(ret.e), true, true);\\n\\\n            }                                                                \\n\\\n            if (!promise._isFateSealed()) promise._setAsyncGuaranteed();     \\n\\\n            return promise;                                                  \\n\\\n        };                                                                   \\n\\\n        notEnumerableProp(ret, '__isPromisified__', true);                   \\n\\\n        return ret;                                                          \\n\\\n    \".replace(\"[CodeForSwitchCase]\", generateArgumentSwitchCase()).replace(\"[GetFunctionCode]\", getFunctionCode);\n      body = body.replace(\"Parameters\", parameterDeclaration(newParameterCount));\n      return new Function(\"Promise\", \"fn\", \"receiver\", \"withAppended\", \"maybeWrapAsError\", \"nodebackForPromise\", \"tryCatch\", \"errorObj\", \"notEnumerableProp\", \"INTERNAL\", body)(Promise, fn, receiver, withAppended, maybeWrapAsError, nodebackForPromise, util.tryCatch, util.errorObj, util.notEnumerableProp, INTERNAL);\n    };\n  }\n\n  function makeNodePromisifiedClosure(callback, receiver, _, fn, __, multiArgs) {\n    var defaultThis = function () {\n      return this;\n    }();\n\n    var method = callback;\n\n    if (typeof method === \"string\") {\n      callback = fn;\n    }\n\n    function promisified() {\n      var _receiver = receiver;\n      if (receiver === THIS) _receiver = this;\n      var promise = new Promise(INTERNAL);\n\n      promise._captureStackTrace();\n\n      var cb = typeof method === \"string\" && this !== defaultThis ? this[method] : callback;\n      var fn = nodebackForPromise(promise, multiArgs);\n\n      try {\n        cb.apply(_receiver, withAppended(arguments, fn));\n      } catch (e) {\n        promise._rejectCallback(maybeWrapAsError(e), true, true);\n      }\n\n      if (!promise._isFateSealed()) promise._setAsyncGuaranteed();\n      return promise;\n    }\n\n    util.notEnumerableProp(promisified, \"__isPromisified__\", true);\n    return promisified;\n  }\n\n  var makeNodePromisified = canEvaluate ? makeNodePromisifiedEval : makeNodePromisifiedClosure;\n\n  function promisifyAll(obj, suffix, filter, promisifier, multiArgs) {\n    var suffixRegexp = new RegExp(escapeIdentRegex(suffix) + \"$\");\n    var methods = promisifiableMethods(obj, suffix, suffixRegexp, filter);\n\n    for (var i = 0, len = methods.length; i < len; i += 2) {\n      var key = methods[i];\n      var fn = methods[i + 1];\n      var promisifiedKey = key + suffix;\n\n      if (promisifier === makeNodePromisified) {\n        obj[promisifiedKey] = makeNodePromisified(key, THIS, key, fn, suffix, multiArgs);\n      } else {\n        var promisified = promisifier(fn, function () {\n          return makeNodePromisified(key, THIS, key, fn, suffix, multiArgs);\n        });\n        util.notEnumerableProp(promisified, \"__isPromisified__\", true);\n        obj[promisifiedKey] = promisified;\n      }\n    }\n\n    util.toFastProperties(obj);\n    return obj;\n  }\n\n  function promisify(callback, receiver, multiArgs) {\n    return makeNodePromisified(callback, receiver, undefined, callback, null, multiArgs);\n  }\n\n  Promise.promisify = function (fn, options) {\n    if (typeof fn !== \"function\") {\n      throw new TypeError(\"expecting a function but got \" + util.classString(fn));\n    }\n\n    if (isPromisified(fn)) {\n      return fn;\n    }\n\n    options = Object(options);\n    var receiver = options.context === undefined ? THIS : options.context;\n    var multiArgs = !!options.multiArgs;\n    var ret = promisify(fn, receiver, multiArgs);\n    util.copyDescriptors(fn, ret, propsFilter);\n    return ret;\n  };\n\n  Promise.promisifyAll = function (target, options) {\n    if (typeof target !== \"function\" && typeof target !== \"object\") {\n      throw new TypeError(\"the target of promisifyAll must be an object or a function\\n\\n    See http://goo.gl/MqrFmX\\n\");\n    }\n\n    options = Object(options);\n    var multiArgs = !!options.multiArgs;\n    var suffix = options.suffix;\n    if (typeof suffix !== \"string\") suffix = defaultSuffix;\n    var filter = options.filter;\n    if (typeof filter !== \"function\") filter = defaultFilter;\n    var promisifier = options.promisifier;\n    if (typeof promisifier !== \"function\") promisifier = makeNodePromisified;\n\n    if (!util.isIdentifier(suffix)) {\n      throw new RangeError(\"suffix must be a valid identifier\\n\\n    See http://goo.gl/MqrFmX\\n\");\n    }\n\n    var keys = util.inheritedDataKeys(target);\n\n    for (var i = 0; i < keys.length; ++i) {\n      var value = target[keys[i]];\n\n      if (keys[i] !== \"constructor\" && util.isClass(value)) {\n        promisifyAll(value.prototype, suffix, filter, promisifier, multiArgs);\n        promisifyAll(value, suffix, filter, promisifier, multiArgs);\n      }\n    }\n\n    return promisifyAll(target, suffix, filter, promisifier, multiArgs);\n  };\n};","map":{"version":3,"sources":["C:/Users/Carlos/Desktop/Coding/doc-to-html/node_modules/bluebird/js/release/promisify.js"],"names":["module","exports","Promise","INTERNAL","THIS","util","require","nodebackForPromise","withAppended","maybeWrapAsError","canEvaluate","TypeError","defaultSuffix","defaultPromisified","__isPromisified__","noCopyProps","noCopyPropsPattern","RegExp","join","defaultFilter","name","isIdentifier","charAt","propsFilter","key","test","isPromisified","fn","e","hasPromisified","obj","suffix","val","getDataPropertyOrDefault","checkValid","ret","suffixRegexp","i","length","keyWithoutAsyncSuffix","replace","j","promisifiableMethods","filter","keys","inheritedDataKeys","value","passesDefaultFilter","push","escapeIdentRegex","str","makeNodePromisifiedEval","switchCaseArgumentOrder","likelyArgumentCount","min","Math","max","argumentSequence","argumentCount","filledRange","parameterDeclaration","parameterCount","callback","receiver","originalName","_","multiArgs","newParameterCount","argumentOrder","shouldProxyThis","generateCallForArgumentCount","count","args","comma","undefined","generateArgumentSwitchCase","getFunctionCode","body","Function","tryCatch","errorObj","notEnumerableProp","makeNodePromisifiedClosure","__","defaultThis","method","promisified","_receiver","promise","_captureStackTrace","cb","apply","arguments","_rejectCallback","_isFateSealed","_setAsyncGuaranteed","makeNodePromisified","promisifyAll","promisifier","methods","len","promisifiedKey","toFastProperties","promisify","options","classString","Object","context","copyDescriptors","target","RangeError","isClass","prototype"],"mappings":"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","sourcesContent":["\"use strict\";\nmodule.exports = function(Promise, INTERNAL) {\nvar THIS = {};\nvar util = require(\"./util\");\nvar nodebackForPromise = require(\"./nodeback\");\nvar withAppended = util.withAppended;\nvar maybeWrapAsError = util.maybeWrapAsError;\nvar canEvaluate = util.canEvaluate;\nvar TypeError = require(\"./errors\").TypeError;\nvar defaultSuffix = \"Async\";\nvar defaultPromisified = {__isPromisified__: true};\nvar noCopyProps = [\n    \"arity\",    \"length\",\n    \"name\",\n    \"arguments\",\n    \"caller\",\n    \"callee\",\n    \"prototype\",\n    \"__isPromisified__\"\n];\nvar noCopyPropsPattern = new RegExp(\"^(?:\" + noCopyProps.join(\"|\") + \")$\");\n\nvar defaultFilter = function(name) {\n    return util.isIdentifier(name) &&\n        name.charAt(0) !== \"_\" &&\n        name !== \"constructor\";\n};\n\nfunction propsFilter(key) {\n    return !noCopyPropsPattern.test(key);\n}\n\nfunction isPromisified(fn) {\n    try {\n        return fn.__isPromisified__ === true;\n    }\n    catch (e) {\n        return false;\n    }\n}\n\nfunction hasPromisified(obj, key, suffix) {\n    var val = util.getDataPropertyOrDefault(obj, key + suffix,\n                                            defaultPromisified);\n    return val ? isPromisified(val) : false;\n}\nfunction checkValid(ret, suffix, suffixRegexp) {\n    for (var i = 0; i < ret.length; i += 2) {\n        var key = ret[i];\n        if (suffixRegexp.test(key)) {\n            var keyWithoutAsyncSuffix = key.replace(suffixRegexp, \"\");\n            for (var j = 0; j < ret.length; j += 2) {\n                if (ret[j] === keyWithoutAsyncSuffix) {\n                    throw new TypeError(\"Cannot promisify an API that has normal methods with '%s'-suffix\\u000a\\u000a    See http://goo.gl/MqrFmX\\u000a\"\n                        .replace(\"%s\", suffix));\n                }\n            }\n        }\n    }\n}\n\nfunction promisifiableMethods(obj, suffix, suffixRegexp, filter) {\n    var keys = util.inheritedDataKeys(obj);\n    var ret = [];\n    for (var i = 0; i < keys.length; ++i) {\n        var key = keys[i];\n        var value = obj[key];\n        var passesDefaultFilter = filter === defaultFilter\n            ? true : defaultFilter(key, value, obj);\n        if (typeof value === \"function\" &&\n            !isPromisified(value) &&\n            !hasPromisified(obj, key, suffix) &&\n            filter(key, value, obj, passesDefaultFilter)) {\n            ret.push(key, value);\n        }\n    }\n    checkValid(ret, suffix, suffixRegexp);\n    return ret;\n}\n\nvar escapeIdentRegex = function(str) {\n    return str.replace(/([$])/, \"\\\\$\");\n};\n\nvar makeNodePromisifiedEval;\nif (!false) {\nvar switchCaseArgumentOrder = function(likelyArgumentCount) {\n    var ret = [likelyArgumentCount];\n    var min = Math.max(0, likelyArgumentCount - 1 - 3);\n    for(var i = likelyArgumentCount - 1; i >= min; --i) {\n        ret.push(i);\n    }\n    for(var i = likelyArgumentCount + 1; i <= 3; ++i) {\n        ret.push(i);\n    }\n    return ret;\n};\n\nvar argumentSequence = function(argumentCount) {\n    return util.filledRange(argumentCount, \"_arg\", \"\");\n};\n\nvar parameterDeclaration = function(parameterCount) {\n    return util.filledRange(\n        Math.max(parameterCount, 3), \"_arg\", \"\");\n};\n\nvar parameterCount = function(fn) {\n    if (typeof fn.length === \"number\") {\n        return Math.max(Math.min(fn.length, 1023 + 1), 0);\n    }\n    return 0;\n};\n\nmakeNodePromisifiedEval =\nfunction(callback, receiver, originalName, fn, _, multiArgs) {\n    var newParameterCount = Math.max(0, parameterCount(fn) - 1);\n    var argumentOrder = switchCaseArgumentOrder(newParameterCount);\n    var shouldProxyThis = typeof callback === \"string\" || receiver === THIS;\n\n    function generateCallForArgumentCount(count) {\n        var args = argumentSequence(count).join(\", \");\n        var comma = count > 0 ? \", \" : \"\";\n        var ret;\n        if (shouldProxyThis) {\n            ret = \"ret = callback.call(this, {{args}}, nodeback); break;\\n\";\n        } else {\n            ret = receiver === undefined\n                ? \"ret = callback({{args}}, nodeback); break;\\n\"\n                : \"ret = callback.call(receiver, {{args}}, nodeback); break;\\n\";\n        }\n        return ret.replace(\"{{args}}\", args).replace(\", \", comma);\n    }\n\n    function generateArgumentSwitchCase() {\n        var ret = \"\";\n        for (var i = 0; i < argumentOrder.length; ++i) {\n            ret += \"case \" + argumentOrder[i] +\":\" +\n                generateCallForArgumentCount(argumentOrder[i]);\n        }\n\n        ret += \"                                                             \\n\\\n        default:                                                             \\n\\\n            var args = new Array(len + 1);                                   \\n\\\n            var i = 0;                                                       \\n\\\n            for (var i = 0; i < len; ++i) {                                  \\n\\\n               args[i] = arguments[i];                                       \\n\\\n            }                                                                \\n\\\n            args[i] = nodeback;                                              \\n\\\n            [CodeForCall]                                                    \\n\\\n            break;                                                           \\n\\\n        \".replace(\"[CodeForCall]\", (shouldProxyThis\n                                ? \"ret = callback.apply(this, args);\\n\"\n                                : \"ret = callback.apply(receiver, args);\\n\"));\n        return ret;\n    }\n\n    var getFunctionCode = typeof callback === \"string\"\n                                ? (\"this != null ? this['\"+callback+\"'] : fn\")\n                                : \"fn\";\n    var body = \"'use strict';                                                \\n\\\n        var ret = function (Parameters) {                                    \\n\\\n            'use strict';                                                    \\n\\\n            var len = arguments.length;                                      \\n\\\n            var promise = new Promise(INTERNAL);                             \\n\\\n            promise._captureStackTrace();                                    \\n\\\n            var nodeback = nodebackForPromise(promise, \" + multiArgs + \");   \\n\\\n            var ret;                                                         \\n\\\n            var callback = tryCatch([GetFunctionCode]);                      \\n\\\n            switch(len) {                                                    \\n\\\n                [CodeForSwitchCase]                                          \\n\\\n            }                                                                \\n\\\n            if (ret === errorObj) {                                          \\n\\\n                promise._rejectCallback(maybeWrapAsError(ret.e), true, true);\\n\\\n            }                                                                \\n\\\n            if (!promise._isFateSealed()) promise._setAsyncGuaranteed();     \\n\\\n            return promise;                                                  \\n\\\n        };                                                                   \\n\\\n        notEnumerableProp(ret, '__isPromisified__', true);                   \\n\\\n        return ret;                                                          \\n\\\n    \".replace(\"[CodeForSwitchCase]\", generateArgumentSwitchCase())\n        .replace(\"[GetFunctionCode]\", getFunctionCode);\n    body = body.replace(\"Parameters\", parameterDeclaration(newParameterCount));\n    return new Function(\"Promise\",\n                        \"fn\",\n                        \"receiver\",\n                        \"withAppended\",\n                        \"maybeWrapAsError\",\n                        \"nodebackForPromise\",\n                        \"tryCatch\",\n                        \"errorObj\",\n                        \"notEnumerableProp\",\n                        \"INTERNAL\",\n                        body)(\n                    Promise,\n                    fn,\n                    receiver,\n                    withAppended,\n                    maybeWrapAsError,\n                    nodebackForPromise,\n                    util.tryCatch,\n                    util.errorObj,\n                    util.notEnumerableProp,\n                    INTERNAL);\n};\n}\n\nfunction makeNodePromisifiedClosure(callback, receiver, _, fn, __, multiArgs) {\n    var defaultThis = (function() {return this;})();\n    var method = callback;\n    if (typeof method === \"string\") {\n        callback = fn;\n    }\n    function promisified() {\n        var _receiver = receiver;\n        if (receiver === THIS) _receiver = this;\n        var promise = new Promise(INTERNAL);\n        promise._captureStackTrace();\n        var cb = typeof method === \"string\" && this !== defaultThis\n            ? this[method] : callback;\n        var fn = nodebackForPromise(promise, multiArgs);\n        try {\n            cb.apply(_receiver, withAppended(arguments, fn));\n        } catch(e) {\n            promise._rejectCallback(maybeWrapAsError(e), true, true);\n        }\n        if (!promise._isFateSealed()) promise._setAsyncGuaranteed();\n        return promise;\n    }\n    util.notEnumerableProp(promisified, \"__isPromisified__\", true);\n    return promisified;\n}\n\nvar makeNodePromisified = canEvaluate\n    ? makeNodePromisifiedEval\n    : makeNodePromisifiedClosure;\n\nfunction promisifyAll(obj, suffix, filter, promisifier, multiArgs) {\n    var suffixRegexp = new RegExp(escapeIdentRegex(suffix) + \"$\");\n    var methods =\n        promisifiableMethods(obj, suffix, suffixRegexp, filter);\n\n    for (var i = 0, len = methods.length; i < len; i+= 2) {\n        var key = methods[i];\n        var fn = methods[i+1];\n        var promisifiedKey = key + suffix;\n        if (promisifier === makeNodePromisified) {\n            obj[promisifiedKey] =\n                makeNodePromisified(key, THIS, key, fn, suffix, multiArgs);\n        } else {\n            var promisified = promisifier(fn, function() {\n                return makeNodePromisified(key, THIS, key,\n                                           fn, suffix, multiArgs);\n            });\n            util.notEnumerableProp(promisified, \"__isPromisified__\", true);\n            obj[promisifiedKey] = promisified;\n        }\n    }\n    util.toFastProperties(obj);\n    return obj;\n}\n\nfunction promisify(callback, receiver, multiArgs) {\n    return makeNodePromisified(callback, receiver, undefined,\n                                callback, null, multiArgs);\n}\n\nPromise.promisify = function (fn, options) {\n    if (typeof fn !== \"function\") {\n        throw new TypeError(\"expecting a function but got \" + util.classString(fn));\n    }\n    if (isPromisified(fn)) {\n        return fn;\n    }\n    options = Object(options);\n    var receiver = options.context === undefined ? THIS : options.context;\n    var multiArgs = !!options.multiArgs;\n    var ret = promisify(fn, receiver, multiArgs);\n    util.copyDescriptors(fn, ret, propsFilter);\n    return ret;\n};\n\nPromise.promisifyAll = function (target, options) {\n    if (typeof target !== \"function\" && typeof target !== \"object\") {\n        throw new TypeError(\"the target of promisifyAll must be an object or a function\\u000a\\u000a    See http://goo.gl/MqrFmX\\u000a\");\n    }\n    options = Object(options);\n    var multiArgs = !!options.multiArgs;\n    var suffix = options.suffix;\n    if (typeof suffix !== \"string\") suffix = defaultSuffix;\n    var filter = options.filter;\n    if (typeof filter !== \"function\") filter = defaultFilter;\n    var promisifier = options.promisifier;\n    if (typeof promisifier !== \"function\") promisifier = makeNodePromisified;\n\n    if (!util.isIdentifier(suffix)) {\n        throw new RangeError(\"suffix must be a valid identifier\\u000a\\u000a    See http://goo.gl/MqrFmX\\u000a\");\n    }\n\n    var keys = util.inheritedDataKeys(target);\n    for (var i = 0; i < keys.length; ++i) {\n        var value = target[keys[i]];\n        if (keys[i] !== \"constructor\" &&\n            util.isClass(value)) {\n            promisifyAll(value.prototype, suffix, filter, promisifier,\n                multiArgs);\n            promisifyAll(value, suffix, filter, promisifier, multiArgs);\n        }\n    }\n\n    return promisifyAll(target, suffix, filter, promisifier, multiArgs);\n};\n};\n\n"]},"metadata":{},"sourceType":"script"}