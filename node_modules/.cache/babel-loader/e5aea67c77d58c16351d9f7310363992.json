{"ast":null,"code":"var JSZip = require(\"jszip\");\n\nexports.openArrayBuffer = openArrayBuffer;\nexports.splitPath = splitPath;\nexports.joinPath = joinPath;\n\nfunction openArrayBuffer(arrayBuffer) {\n  return JSZip.loadAsync(arrayBuffer).then(function (zipFile) {\n    function exists(name) {\n      return zipFile.file(name) !== null;\n    }\n\n    function read(name, encoding) {\n      return zipFile.file(name).async(\"uint8array\").then(function (array) {\n        var buffer = uint8ArrayToBuffer(array);\n\n        if (encoding) {\n          return buffer.toString(encoding);\n        } else {\n          return buffer;\n        }\n      });\n    }\n\n    function write(name, contents) {\n      zipFile.file(name, contents);\n    }\n\n    function toBuffer() {\n      return zipFile.generateAsync({\n        type: \"nodebuffer\"\n      });\n    }\n\n    return {\n      exists: exists,\n      read: read,\n      write: write,\n      toBuffer: toBuffer\n    };\n  });\n}\n\nfunction uint8ArrayToBuffer(array) {\n  if (Buffer.from && Buffer.from !== Uint8Array.from) {\n    return Buffer.from(array);\n  } else {\n    return new Buffer(array);\n  }\n}\n\nfunction splitPath(path) {\n  var lastIndex = path.lastIndexOf(\"/\");\n\n  if (lastIndex === -1) {\n    return {\n      dirname: \"\",\n      basename: path\n    };\n  } else {\n    return {\n      dirname: path.substring(0, lastIndex),\n      basename: path.substring(lastIndex + 1)\n    };\n  }\n}\n\nfunction joinPath() {\n  var nonEmptyPaths = Array.prototype.filter.call(arguments, function (path) {\n    return path;\n  });\n  var relevantPaths = [];\n  nonEmptyPaths.forEach(function (path) {\n    if (/^\\//.test(path)) {\n      relevantPaths = [path];\n    } else {\n      relevantPaths.push(path);\n    }\n  });\n  return relevantPaths.join(\"/\");\n}","map":{"version":3,"sources":["C:/Users/Carlos/Desktop/Coding/doc-to-html/node_modules/mammoth/lib/zipfile.js"],"names":["JSZip","require","exports","openArrayBuffer","splitPath","joinPath","arrayBuffer","loadAsync","then","zipFile","exists","name","file","read","encoding","async","array","buffer","uint8ArrayToBuffer","toString","write","contents","toBuffer","generateAsync","type","Buffer","from","Uint8Array","path","lastIndex","lastIndexOf","dirname","basename","substring","nonEmptyPaths","Array","prototype","filter","call","arguments","relevantPaths","forEach","test","push","join"],"mappings":"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","sourcesContent":["var JSZip = require(\"jszip\");\n\nexports.openArrayBuffer = openArrayBuffer;\nexports.splitPath = splitPath;\nexports.joinPath = joinPath;\n\nfunction openArrayBuffer(arrayBuffer) {\n    return JSZip.loadAsync(arrayBuffer).then(function(zipFile) {\n        function exists(name) {\n            return zipFile.file(name) !== null;\n        }\n\n        function read(name, encoding) {\n            return zipFile.file(name).async(\"uint8array\").then(function(array) {\n                var buffer = uint8ArrayToBuffer(array);\n                if (encoding) {\n                    return buffer.toString(encoding);\n                } else {\n                    return buffer;\n                }\n            });\n        }\n\n        function write(name, contents) {\n            zipFile.file(name, contents);\n        }\n\n        function toBuffer() {\n            return zipFile.generateAsync({type: \"nodebuffer\"});\n        }\n\n        return {\n            exists: exists,\n            read: read,\n            write: write,\n            toBuffer: toBuffer\n        };\n    });\n}\n\nfunction uint8ArrayToBuffer(array) {\n    if (Buffer.from && Buffer.from !== Uint8Array.from) {\n        return Buffer.from(array);\n    } else {\n        return new Buffer(array);\n    }\n}\n\nfunction splitPath(path) {\n    var lastIndex = path.lastIndexOf(\"/\");\n    if (lastIndex === -1) {\n        return {dirname: \"\", basename: path};\n    } else {\n        return {\n            dirname: path.substring(0, lastIndex),\n            basename: path.substring(lastIndex + 1)\n        };\n    }\n}\n\nfunction joinPath() {\n    var nonEmptyPaths = Array.prototype.filter.call(arguments, function(path) {\n        return path;\n    });\n\n    var relevantPaths = [];\n\n    nonEmptyPaths.forEach(function(path) {\n        if (/^\\//.test(path)) {\n            relevantPaths = [path];\n        } else {\n            relevantPaths.push(path);\n        }\n    });\n\n    return relevantPaths.join(\"/\");\n}\n"]},"metadata":{},"sourceType":"script"}